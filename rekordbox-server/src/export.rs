//! USB Export generation
//!
//! Creates the complete Pioneer-compatible USB directory structure:
//! - PIONEER/rekordbox/export.pdb
//! - PIONEER/USBANLZ/Pxxx/[hex]/ANLZ0000.DAT
//! - Contents/[audio files]

use std::fs::{self, File};
use std::io::Write;
use std::path::Path;

use tracing::{info, debug};

use rekordbox_core::anlz::{generate_dat_file, generate_anlz_path};
use rekordbox_core::pdb::PdbBuilder;
use rekordbox_core::track::TrackAnalysis;

/// Export analyzed tracks to Pioneer USB format
pub fn export_usb(tracks: &[TrackAnalysis], output_dir: &Path) -> anyhow::Result<()> {
    info!("Exporting {} tracks to {:?}", tracks.len(), output_dir);
    
    // Create directory structure
    let pioneer_dir = output_dir.join("PIONEER");
    let rekordbox_dir = pioneer_dir.join("rekordbox");
    let anlz_dir = pioneer_dir.join("USBANLZ");
    let contents_dir = output_dir.join("Contents");
    
    fs::create_dir_all(&rekordbox_dir)?;
    fs::create_dir_all(&anlz_dir)?;
    fs::create_dir_all(&contents_dir)?;
    
    // Build PDB database
    let mut pdb_builder = PdbBuilder::new();
    
    for track in tracks {
        let anlz_path = generate_anlz_path(track.id);
        pdb_builder.add_track(track, &anlz_path);
    }
    
    // Write export.pdb
    let pdb_data = pdb_builder.build()?;
    let pdb_path = rekordbox_dir.join("export.pdb");
    let mut pdb_file = File::create(&pdb_path)?;
    pdb_file.write_all(&pdb_data)?;
    info!("Wrote export.pdb ({} bytes)", pdb_data.len());
    
    // Generate ANLZ files for each track
    for track in tracks {
        let anlz_rel_path = generate_anlz_path(track.id);
        let anlz_full_path = output_dir.join(&anlz_rel_path);
        
        // Create parent directories
        if let Some(parent) = anlz_full_path.parent() {
            fs::create_dir_all(parent)?;
        }
        
        // Generate .DAT file
        let dat_data = generate_dat_file(
            &track.beat_grid,
            &track.waveform,
            &track.file_path,
        )?;
        
        let mut dat_file = File::create(&anlz_full_path)?;
        dat_file.write_all(&dat_data)?;
        debug!("Wrote ANLZ for track {}: {:?}", track.id, anlz_full_path);
        
        // Also generate .EXT file for Nexus+ compatibility
        let ext_path = anlz_full_path.with_extension("EXT");
        let ext_data = generate_dat_file(
            &track.beat_grid,
            &track.waveform,
            &track.file_path,
        )?;
        let mut ext_file = File::create(&ext_path)?;
        ext_file.write_all(&ext_data)?;
    }
    
    info!("Export complete: {} tracks", tracks.len());
    
    // Write a manifest for debugging
    let manifest_path = output_dir.join("EXPORT_MANIFEST.txt");
    let mut manifest = File::create(&manifest_path)?;
    writeln!(manifest, "Rekordbox Export Manifest")?;
    writeln!(manifest, "Generated by rekordbox-export")?;
    writeln!(manifest, "Tracks: {}", tracks.len())?;
    writeln!(manifest, "")?;
    for track in tracks {
        writeln!(manifest, "{}: {} - {} ({:.1} BPM)", 
                 track.id, track.artist, track.title, track.bpm)?;
    }
    
    Ok(())
}

/// Validate USB filesystem requirements
pub fn validate_usb_target(path: &Path) -> anyhow::Result<()> {
    // Check if directory exists and is writable
    if !path.exists() {
        anyhow::bail!("Target path does not exist: {:?}", path);
    }
    
    if !path.is_dir() {
        anyhow::bail!("Target path is not a directory: {:?}", path);
    }
    
    // Try to create a test file
    let test_file = path.join(".rekordbox_test");
    match File::create(&test_file) {
        Ok(_) => {
            fs::remove_file(&test_file)?;
        }
        Err(e) => {
            anyhow::bail!("Cannot write to target directory: {}", e);
        }
    }
    
    // Note: We can't easily check for FAT32 from Rust without platform-specific code
    // User should ensure the USB is formatted as FAT32 with MBR partition table
    
    Ok(())
}

/// Copy audio files to Contents directory
pub fn copy_audio_files(
    tracks: &[TrackAnalysis],
    source_dir: &Path,
    output_dir: &Path,
) -> anyhow::Result<()> {
    let contents_dir = output_dir.join("Contents");
    fs::create_dir_all(&contents_dir)?;
    
    for track in tracks {
        // Find source file
        let source_path = source_dir.join(&track.file_path.replace("Contents/", ""));
        
        if !source_path.exists() {
            // Try finding by filename in source tree
            let filename = Path::new(&track.file_path)
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("");
            
            for entry in walkdir::WalkDir::new(source_dir)
                .into_iter()
                .filter_map(|e| e.ok())
            {
                if entry.file_name().to_str() == Some(filename) {
                    let dest_path = contents_dir.join(filename);
                    fs::copy(entry.path(), &dest_path)?;
                    debug!("Copied: {:?} -> {:?}", entry.path(), dest_path);
                    break;
                }
            }
        } else {
            let filename = source_path.file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("unknown");
            let dest_path = contents_dir.join(filename);
            fs::copy(&source_path, &dest_path)?;
        }
    }
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    
    #[test]
    fn test_validate_writable() {
        let tmp = TempDir::new().unwrap();
        assert!(validate_usb_target(tmp.path()).is_ok());
    }
}
